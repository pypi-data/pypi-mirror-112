Metadata-Version: 2.1
Name: django-browsable-router
Version: 0.0.6
Summary: A Django Restframework router that can show APIViews and include other routers as navigable urls in the root view.
Home-page: https://github.com/MrThearMan/django-browsable-router/
Author: Matti Lamppu
Author-email: lamppu.matti.akseli@gmail.com
License: UNKNOWN
Project-URL: Bug Tracker, https://github.com/MrThearMan/django-browsable-router/issues
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE

# Django Browsable Router

```
pip install django-browsable-router
```

A Django Restframework router that can show APIViews and include other routers as navigable urls in the root view.

```python
from browsable_router import APIRouter
from rest_framework.views import APIView
from rest_framework.viewsets import ViewSet

class TestView(APIView):
  ...
 
class TestViewSet(ViewSet):
  ...

router_1 = APIRouter(name="other_routes", docstring="These are under a different route.")
router_1.register(r"view-1", TestView.as_view(), "view_1")
router_1.register(r"view-2", TestViewSet.as_view(), "view_2")

router_2 = APIRouter()
router_2.register(r"view-3", TestView.as_view(), "view_3")
router_2.navigation_routes = {
    "route": router_1,
}

urlpatterns = [
    path("api/", include(router_2.urls))
]
```

Resulting browsable API:
```python
#   API Root:
#   """API root."""
# 
#   "route":    "/api/route/"
#   "view-3":   "/api/view-3/"
# 
#   Other Routes:
#   """These are under a different route."""
# 
#   "view-1":    "/api/route/view-1/"
#   "view-2":    "/api/route/view-2/"
```

---

# Additional stuff:

### BaseAPIView

A custom APIView class that is designed for input and output verification. 
It allows different serializers for different HTTP methods. 
Simpy inherit from the class and any number of the included mixins. 
Then define the serializers per HTTP method in the 'pipelines' attribute.

Pipelines takes a tuple of the InputSerializer, logic method, and OutputSerializer
Logic method has to return data that the OutputSerializer can serialize.
This forces verification for the output, so that if something changes in the logic,
or some unexpected values are returned, the endpoint will break instead of creating side effects.

```python
from browsable_router import BaseAPIView, GetMixin, PostMixin
from rest_framework.serializers import Serializer

def get_method_logic(**kwargs):
    ...

def post_method_logic(**kwargs):
    ...

class SomeCustomView(GetMixin, PostMixin, BaseAPIView):

  class GetInputSerializer(Serializer):
    ...
  
  class GetOutputSerializer(Serializer):
    ...
    
  class PostInputSerializer(Serializer):
    ...
  
  class PostOutputSerializer(Serializer):
    ...

  serializer_classes = {
    "GET": (GetInputSerializer, get_method_logic, GetOutputSerializer),
    "POST": (PostInputSerializer, post_method_logic, PostOutputSerializer),
  }
```

### ApiMetadata
This metadata class is enabled by default on BaseAPIView, and it will allow you to document your views automatically.
Basically, it reads the InputSerializers fields as input, and the OutputSerializer fields as the output for each HTTP method for that view. 
You can then make a OPTIONS request to the view endpoint and get a JSON Schema-ish representation of the input and output for that endpoint.

### SerializerAsOutputMetadata
This metadata class works like APIMetadata class, but is intended for the generic views that come with django rest framework.
It assumes that the endpoint takes no arguments and returns the method serializers fields as output.

### BlockSchemaAccess
This is a permission class that can be used to block access to OPTIONS schema in production (DEBUG=False).


