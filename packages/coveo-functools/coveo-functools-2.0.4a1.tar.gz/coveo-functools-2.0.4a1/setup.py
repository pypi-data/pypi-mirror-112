# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['coveo_functools']

package_data = \
{'': ['*']}

install_requires = \
['inflection', 'typing_extensions']

setup_kwargs = {
    'name': 'coveo-functools',
    'version': '2.0.4a1',
    'description': 'Generic function tooling helpers',
    'long_description': '# coveo-functools\n\nIntrospection, finalizers, delegates, dispatchers, waiters...\nThese utilities aim at increasing productivity.\n\n\n## annotations\n\nIntrospect classes and callables at runtime.\n\nCan convert string annotations into their actual type reference.\n\n\n## flex\n\nFlex takes a "dirty" input and maps it to a python construct.\n\nThe principal use case is to allow seamless translation between snake_case and camelCase and generate PEP8-compliant code over APIs that support a different casing scheme.\n\n- It introspects a function/class to obtain the expected argument names\n- It inspects the provided input to find matching candidates\n- It calls the function with the cleaned arguments\n- It can recurse into nested custom types based on annotations\n- It strips out the data you don\'t need from the payload\n\nIt can also be used to allow for a certain degree of personalization in typically strict contexts such as configuration files and APIs. \n\nTake for example the toml below, where all 3 items can be made equivalent:\n\n```toml\n[tool.some-plugin]\nenable_features = [\'this\', \'that\']\nenable-features = [\'this\', \'that\']\nenableFeatures = [\'this\', \'that\']\n```\n\nOr maybe in a CLI app, to allow both underscores and dashes:\n\n```shell\n# which one was it?\npoetry install --no-dev\npoetry install --no_dev\n```\n\n### @flex\n\nThis decorator will wrap a class, method or function so that it can be called with flexible arguments:\n\n```python\nfrom coveo_functools.flex import flex\n\nPAYLOAD = {"TEST": "SUCCESS"}\n\n@flex\nclass FlexibleConstructor:\n    def __init__(self, test: str) -> None:\n        self.test = test\n\n    @flex\n    def flexible_method(self, test: str) -> str:\n        return test\n\n\n@flex\ndef flexible_function(test: str) -> str:\n    return test\n\ninstance = FlexibleConstructor(**PAYLOAD)\n\nassert instance.test == "SUCCESS"\nassert instance.flexible_method(**PAYLOAD) == "SUCCESS"\nassert flexible_function(**PAYLOAD) == "SUCCESS"\n\n\n# you can also use the tool inline; for instance to wrap a 3rd party lib:\ndef typical_function(test: str) -> str:\n    return test\n\nassert flex(typical_function)(**PAYLOAD) == "SUCCESS"\n```\n\nLet\'s see a more practical example:\n\n```python\nfrom dataclasses import dataclass\n\nimport requests  # noqa\nfrom coveo_functools.flex import flex\n\n\n@dataclass\nclass Owner:\n    login: str\n\n\n@flex\n@dataclass\nclass ApiResponse:\n    id: int\n    owner: Owner\n\n# Consider this api response:\n# {\n#     "Id": 1234,\n#     "Owner": {"login": "jonapich"},\n#     "Url": "https://..."\n# }\nresponse = ApiResponse(**requests.get(...).json)\nassert response.owner.login == \'jonapich\'\n```\n\nIn the example above, notice how Owner doesn\'t have to be decorated?\nThis is because @flex works recursively on any type.\nYou can decorate it too, but the first call is what matters.\n\n#### consideration vs mypy\n\nThere is one annotation case worth mentioning. \nConsider this code:\n\n```python\nclass Inner:\n    ...\n\n@flex\ndef fn(inner: Inner) -> ...:\n    ...\n\n_ = fn(**{\'inner\': {...}})\n```\n\nIn this case, mypy will infer that you\'re doing `**Dict[str, Dict]`\nand complain that Dict is not compatible with Inner.\n\nTo solve this without an ignore statement, \nexplicitly annotate/cast your payloads with Any:\n\n```python\npayload: Dict[str, Any] = {"inner": {}}\n_ = fn(**payload)\n```\n\n### unflex\n\nUnflex is one of the utilities used by the @flex decorator.\n\nIt can remap a dictionary to fit the keyword arguments (casing/etc) given by a callable:\n\n```python\nfrom coveo_functools.flex import unflex\n\ndef fn(arg1: str, arg2: str) -> None:\n    ...\n\nassert unflex(fn, {"ARG1": ..., "ArG_2": ...}) == {"arg1": ..., "arg2": ...}\n```\n\n### @flexcase\n\n`flexcase` is a simpler version of the flex decorator.\nIt allows a function to apply the `unflex` logic automatically against a callable.\n\nUnlike the flex decorator, it is not recursive and it will\nnot attempt to read type annotations or convert values.\n\n\n```python\nfrom coveo_functools.flex import flexcase\n\n@flexcase\ndef fn(arg1: str, arg2: str) -> str:\n    return f"{arg1} {arg2}"\n\n\nassert fn(ARG1="hello", _arg2="world") == "hello world"\n```\n\n\n## dispatch\n\nAn enhanced version of [functools.singledispatch](https://docs.python.org/3.8/library/functools.html#functools.singledispatch):\n\n\n- Adds support for `Type[]` annotations (singledispatch only works on instances)\n- You are no longer limited to the first argument of the method\n- You can target an argument by its name too, regardless of its position\n\n\n## finalizer\n\nA classic and simple try/finally context manager that launches a delegate once a block of code has completed.\n\nA common trick is to "cook" the finalizer arguments through a mutable type such as a list or dict:\n\n```python\nfrom typing import List\nfrom coveo_functools.finalizer import finalizer\n\ndef clean_up(container_names: List[str]) -> None:\n    for _ in container_names:\n        ...\n    \ndef test_spawning_containers() -> None:\n    containers: List[str] = []\n    with finalizer(clean_up, containers):\n        containers.append(\'some-container-1\')\n        containers.append(\'some-container-2\')\n        containers.append(\'some-container-3\')\n```\n\n\n## wait.until()\n\nWaits for a condition to happen. Can be configured with exceptions to ignore.\n\n```python\nfrom coveo_functools import wait\nimport requests\n\ndef _ready() -> bool:\n    return requests.get(\'/ping\').status_code == 200\n\nwait.until(_ready, timeout_s=30, retry_ms=100, handle_exceptions=ConnectionError,\n           failure_message="The service failed to respond in time.")\n```\n\n## wait.Backoff\n\nA customizable class to assist in the creation of backoff retry strategies.\n\n- Customizable growth factor\n- Jitter\n- Backoff progress % (want to fire some preliminary alarms at 50% backoff maybe?)\n- Supports infinite backoff\n- Can be configured to raise after too many attempts\n- Can be configured to raise after a set amount of time\n\ne.g.: Worker loop failure management by catching RetriesExhausted\n\n```python\nfrom coveo_functools.wait import Backoff\n\nbackoff = Backoff()\nwhile my_loop:\n    try:\n        do_stuff()\n    except Exception as exception:\n        try:\n            quit_flag.wait(next(backoff))\n        except backoff.RetriesExhausted:\n            raise exception\n```\n\ne.g.: Worker loop failure management without the nested try/catch:\n\n```python\nfrom coveo_functools.wait import Backoff\n\nbackoff = Backoff()\nwhile my_loop:\n    try:\n        do_stuff()\n    except Exception as exception:\n        wait_time = next(backoff, None)\n        if wait_time is None:\n            raise exception\n        quit_flag.wait(wait_time)\n```\n\ne.g.: You can generate the wait times without creating a Backoff instance, too:\n\n```python\nimport time\nfrom coveo_functools.wait import Backoff\n\nwait_times = list(Backoff.generate_backoff_stages(first_wait, growth, max_backoff))\nfor sleep_time in wait_times:\n    try:\n        do_stuff()\n        break\n    except:\n        time.sleep(sleep_time)\nelse:\n    raise ImSickOfTrying()\n```\n',
    'author': 'Jonathan PichÃ©',
    'author_email': 'tools@coveo.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/coveooss/coveo-python-oss/tree/main/coveo-functools',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8',
}


setup(**setup_kwargs)
