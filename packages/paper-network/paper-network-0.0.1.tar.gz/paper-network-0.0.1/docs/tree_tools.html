<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>PAPER.tree_tools API documentation</title>
<meta name="description" content="Created on Fri Sep 18 21:10:19 2020 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PAPER.tree_tools</code></h1>
</header>
<section id="section-intro">
<p>Created on Fri Sep 18 21:10:19 2020</p>
<p>@author: minx</p>
<p>important invariants in the code:
graf.vs has attribute "pa", "subtree_size"
graf.es has attribute "tree"</p>
<p>function "wilsonTree(graf)" adds "tree" attribute
function "countSubtreeSizes(graf, root)" require "tree" attribute
on the edges and creates "subtree_size" and "pa"</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Fri Sep 18 21:10:19 2020

@author: minx


important invariants in the code:
graf.vs has attribute &#34;pa&#34;, &#34;subtree_size&#34;
graf.es has attribute &#34;tree&#34;

function &#34;wilsonTree(graf)&#34; adds &#34;tree&#34; attribute
function &#34;countSubtreeSizes(graf, root)&#34; require &#34;tree&#34; attribute 
      on the edges and creates &#34;subtree_size&#34; and &#34;pa&#34;
&#34;&#34;&#34;

import time
from random import choices
from igraph import *
import numpy as np
import collections
import scipy.optimize



def getAllTreeDeg(graf):
    &#34;&#34;&#34;
    Computes tree degree of all nodes in input graph.

    Parameters
    ----------
    graf : igraph object
        Graph with tree attribute on edges.

    Returns
    -------
    np array of the tree degrees of all nodes.

    &#34;&#34;&#34;
    n = len(graf.vs)
    degs = [0] * n
    for mye in graf.es:
        if (mye[&#34;tree&#34;]):
            degs[mye.source] = degs[mye.source] + 1
            degs[mye.target ] = degs[mye.target] + 1
    degs = np.array(degs)
    return(degs)




def treeDegree(graf, v):
    &#34;&#34;&#34;
    Computes tree degree of a single node v of the input graph

    Parameters
    ----------
    graf : igraph object
        Graph with tree attribute on edges.
    v : int
        node id.

    Returns
    -------
    tree degree of v as a single integer.

    &#34;&#34;&#34;
    
    edge_ixs = graf.incident(v)
    
    deg = sum([e[&#34;tree&#34;] for e in graf.es[edge_ixs]])
    
    return(deg)




def getAncestors(graf, utilde, u = None):
    &#34;&#34;&#34;
    Returns ancestors utilde, avoiding u.

    Parameters
    ----------
    graf : igraph object
        Input graph.
    utilde : int
        node id.
    u : int, optional
        node id. The default is None.

    Returns
    -------
    -1 if parents of utilde trace to u, 
          otherwise return list of parents of utilde, including utilde, including the root.

    &#34;&#34;&#34;
    
    cur_node = utilde
    ants = [cur_node]
    
    while (True):
        my_pa = graf.vs[cur_node][&#34;pa&#34;]
        
        if (my_pa == None):
            return(ants)

        assert graf.vs[cur_node][&#34;subtree_size&#34;] &lt; graf.vs[my_pa][&#34;subtree_size&#34;]
        
        if (my_pa == u):
            return(-1)
        else:
            ants.append(my_pa)
            cur_node = my_pa
 
        
 
    
def otherNode(my_edge, node_ix):
    &#34;&#34;&#34;
    Gives other node id of a given edge and one endpoint id

    Parameters
    ----------
    my_edge : igraph edge object
        Input edge.
    node_ix : int
        One endpoint id.

    Returns
    -------
    Node id of the other endpoint.

    &#34;&#34;&#34;
    if (my_edge.source == node_ix):
        return(my_edge.target)
    else:
        return(my_edge.source)      



def bfsTree(graf, root=0):
    &#34;&#34;&#34;
    Creates a tree from a given node by breadth-first-search

    Parameters
    ----------
    graf : igraph object
        Input graph.
    root : int, optional
        Start node id. The default is 0.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    n = len(graf.vs)
    
    graf.vs[&#34;marked&#34;] = False
    graf.es[&#34;tree&#34;] = False
    
    graf.vs[root][&#34;marked&#34;] = True
    
    myqueue = [root]
    
    while (len(myqueue) &gt; 0):
        v = myqueue.pop(0)
        
        edge_ixs = graf.incident(v)
        shuffle(edge_ixs)
        
        for eid in edge_ixs:
            my_e = graf.es[eid]
            u = otherNode(my_e, v)
            
            if (not graf.vs[u][&#34;marked&#34;]):
                my_e[&#34;tree&#34;] = True
                graf.vs[u][&#34;marked&#34;] = True
                myqueue.append(u)
                

def wilsonTree(graf, root=0, display=False):
    &#34;&#34;&#34;
    Creates a tree from a given node by uniform sampling
    from the set of spanning trees by Wilson&#39;s algorithm. 
    The starting node can be arbitrary. 

    Adds &#34;tree&#34; attribute to input graph edges.

    Parameters
    ----------
    graf : igraph object
        Input graph.
    root : int, optional
        Start node id; Does not affect output tree. The default is 0.
    display : boolean, optional
        Display details. The default is False.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    
    n = len(graf.vs)
    vertex_seq = range(n)
    
    graf.es[&#34;tree&#34;] = False
    graf.vs[&#34;marked&#34;] = False
    graf.vs[root][&#34;marked&#34;] = True
    
    
    def loopErase(mylist):
        occur = {}
        for ii in range(len(mylist)):
            occur[mylist[ii]] = ii
            
        outlist = []
        ii = 0
        while (True):
            if ii &gt;= len(mylist):
                return(outlist)
            
            if (occur[mylist[ii]] == ii):
                outlist.append(mylist[ii])
                ii = ii + 1
            else:
                ii = occur[mylist[ii]]
        
    
    def loopErasedRW(start):
        cur_node = start
        node_ls = [cur_node]
        
        while (True):
            cur_node = choices(graf.neighbors(cur_node), k=1)[0]
            node_ls.append(cur_node)
            
            #if (cur_node == start):
            #    node_ls = [cur_node]
                
            if (graf.vs[cur_node][&#34;marked&#34;]):
                
                node_ls = loopErase(node_ls)
                
                graf.vs[node_ls][&#34;marked&#34;] = True
                my_edge_ids = graf.get_eids(path=node_ls)
                
                graf.es[my_edge_ids][&#34;tree&#34;] = True
                return
            
            
    for ii in vertex_seq:
        if (display):
            if (ii % 10000 == 0):
                print((ii, n))
        if graf.vs[ii][&#34;marked&#34;]:
            continue
        else:
            loopErasedRW(ii)
            
    return


def createNoisyGraph(n, m, alpha=0, beta=1, K=1):
    &#34;&#34;&#34;
    Generates a new graph from PAPER(alpha, beta, K, theta) model
    with n nodes and m edges. 
    Note: theta parameter not used since m is fixed.

    Parameters
    ----------
    n : int
        Num nodes.
    m : int
        Num edges.
    alpha : float, optional
        Parameter. The default is 0.
    beta : float, optional
        Parameter. The default is 1.
    K : int, optional
        Num of clusters. The default is 1.

    Returns
    -------
    0. igraph object
    1. list representation of the underlying tree
       where i-th element is the root of node i

    &#34;&#34;&#34;
    
    res = createPATree(n, alpha, beta, K)
    mytree = res[0]
    clust = res[1]
    
    addRandomEdges(mytree, m)
    return((mytree, clust))
        

def addRandomEdges(graf, m):
    &#34;&#34;&#34;
    Add random Erdos--Renyi edges to input graph
    until the graph has m edges.

    Parameters
    ----------
    graf : igraph object
        Input graph.
    m : int
        Final num of edges.

    Returns
    -------
    igraph object.

    &#34;&#34;&#34;
    
    n = len(graf.vs)
    assert m &lt; n*(n-1)/2
    
    while(len(graf.es) &lt; m):
        m2 = m - len(graf.es)
        
        heads = choices(range(n), k=m2)
        tails = choices(range(n), k=m2)
        
        edgelist = [(heads[j], tails[j]) for j in range(m2) if heads[j] != tails[j]]

        graf.add_edges(edgelist)
        graf.simplify()
        
    return(graf)        


def createPATree(n, alpha=0, beta=1, K=1):
    &#34;&#34;&#34;
    Generates an APA(alpha, beta, K) forest.
    Default parameter is LPA.

    Parameters
    ----------
    n : int
        Num nodes.
    alpha : float, optional
        Parameter. The default is 0.
    beta : float, optional
        Parameter. The default is 1.
    K : int, optional
        Num of component trees. The default is 1.

    Returns
    -------
    0. igraph object.
    1. list representation of the underlying forest
       where i-th element is the root of node i

    &#34;&#34;&#34;
    mytree = Graph()
    
    mytree.add_vertices(n)
    edge_ls = []
    
    ## parent of every node; -1 if root
    ## tree ID of every node
    pa_vec = [-1] * n
    tree_vec = [0] * n 
    
    if (K == 1):
        mytree.add_edges( [(0,1)] )
        wt_ls = [alpha+beta, alpha+beta]
        pa_vec[1] = 0
        initi = 2
    else :
        wt_ls = [alpha + 2*beta] * K
        initi = K
        for k in range(K):
            tree_vec[k] = k
    
    for i in range(initi, n):
        
        if (alpha == 1 and beta ==0):
            cur_node = choices(range(i))[0]
        else:
            cur_node = choices(range(i), weights=wt_ls)[0]
        
        wt_ls.append(alpha+beta)
        wt_ls[cur_node] = wt_ls[cur_node] + beta        
        edge_ls.append((cur_node, i))
        
        pa_vec[i] = cur_node
        
        while (pa_vec[cur_node] != -1):
            cur_node = pa_vec[cur_node]
        
        tree_vec[i] = cur_node
        
        
    mytree.add_edges(edge_ls)
    return((mytree, tree_vec))



def countSubtreeSizes(graf, root, prev=None):
    &#34;&#34;&#34;
    Creates new node attribute &#34;subtree_size&#34; and &#34;pa&#34;
    giving the subtree sizes and parent of each node viewing the 
    input tree as being rooted at a given node.
    
    Require: input graph edges have &#34;tree&#34; attribute.

    Parameters
    ----------
    graf : igraph object
        Input graph; creates node attribute &#34;subtree_size&#34; on graf
        creates node attribute &#34;pa&#34; on graf
    root : int
        Node id of root.
    prev : int, optional
        Internal variable used for recursion. The default is None.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    n = len(graf.vs)
    istree = len(graf.es) == (n-1)

    graf.vs[root][&#34;pa&#34;] = prev
    
    counter = 1
    
    edge_ixs = graf.incident(root)
    
    for eid in edge_ixs:
        my_e = graf.es[eid]
        if (not istree) and (not my_e[&#34;tree&#34;]):
            continue
        
        next_node = otherNode(my_e, root)
            
        if (next_node == prev):
            continue
        else:
            counter = counter + countSubtreeSizes(graf, next_node, root)
        
    graf.vs[root][&#34;subtree_size&#34;] = counter
    return(counter)



def countAllHist(graf, root):
    &#34;&#34;&#34;
    Computes posterior root probs for a given tree. 
    Require: graf.es has &#34;tree&#34; attribute; graf.vs 
            has &#34;subtree_size&#34; and &#34;pa&#34; attributes.

    Parameters
    ----------
    graf : igraph object
        Input graph.
    root : int
        Root node id. Computes posterior root prob
        for the tree containing root. 

    Returns
    -------
    0. nparray of posterior root probs
    1. cardinality of all histories of input tree
    2. largest h(u,t) value in log-scale

    &#34;&#34;&#34;
    n = len(graf.vs)
    
    countSubtreeSizes(graf, root)
    hist = [0] * n
    
    ntree = graf.vs[root][&#34;subtree_size&#34;]
    
    S = collections.deque([root]) ## queue of nodes to visit

    hist[root] = 0
    tree_nodes = []
    
    while (len(S) &gt; 0):
        cur_node = S.popleft()
        tree_nodes.append(cur_node)
        
        hist[root] = hist[root] - np.log(graf.vs[cur_node][&#34;subtree_size&#34;])

        node_ixs = graf.neighbors(cur_node)
        for next_node in node_ixs:
            
            if (graf.vs[next_node][&#34;pa&#34;] != cur_node):
                continue
            S.append(next_node)
            
    S = collections.deque([root]) ## queue of nodes to visit
    
    while (len(S) &gt; 0):
        cur_node = S.popleft()
    
        node_ixs = graf.neighbors(cur_node)
        
        for next_node in node_ixs:
            
            if (graf.vs[next_node][&#34;pa&#34;] != cur_node):
                continue
            
            S.append(next_node)
            
            hist[next_node] = hist[cur_node] + \
                    np.log(graf.vs[next_node][&#34;subtree_size&#34;] /  \
                           (ntree - graf.vs[next_node][&#34;subtree_size&#34;]))
            
            
    loghist = np.array(hist)
    
    thist = np.array([0] * n, dtype=float)

    thist[tree_nodes] = np.exp(loghist[tree_nodes] - max(loghist[tree_nodes]))

    return((thist/np.sum(thist), np.sum(thist), max(loghist)))
        


def treeDFS(graf, start, v_ls=None):
    &#34;&#34;&#34;
    Require: edges of &#34;graf&#34; has a &#34;tree&#34; attribute

    Parameters
    ----------
    graf : igraph object
        Input graph.
    start : int
        Start node id.
    v_ls : list, optional
        List of nodes. The default is None.

    Returns
    -------
    0. sublist of v_ls of all nodes in the tree
       containg start node. If v_ls==None, returns
       list of all nodes of tree containing start node.

    &#34;&#34;&#34;
    
    stak = [start]
    
    visited = {}
    
    while (len(stak) &gt; 0):
        cur_v = stak.pop(-1)
        visited[cur_v] = 1
        tree_edges = [e for e in graf.incident(cur_v) if graf.es[e][&#34;tree&#34;]]
        tree_nbs = [otherNode(graf.es[e], cur_v) for e in tree_edges]
    
        for u in tree_nbs:
            if u not in visited:
                stak.append(u)
    if (v_ls != None):
        tmp = [v for v in v_ls if v in visited]
    else:
        tmp = list(visited.keys())
        
    return(tmp)




def getTreeSizes(graf, tree2root):
    &#34;&#34;&#34;

    Parameters
    ----------
    graf : igraph object
        Input graph.
    tree2root : list
        Root node of all trees.

    Returns
    -------
    0. list of sizes of all trees

    &#34;&#34;&#34;
    n = len(graf.vs)
    all_sizes = []
    for k in range(len(tree2root)):
        cur_tree = treeDFS(graf, tree2root[k], range(n))
        all_sizes.append(len(cur_tree))
    
    assert sum(np.array(all_sizes)) == n
    
    return(all_sizes)

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PAPER.tree_tools.addRandomEdges"><code class="name flex">
<span>def <span class="ident">addRandomEdges</span></span>(<span>graf, m)</span>
</code></dt>
<dd>
<div class="desc"><p>Add random Erdos&ndash;Renyi edges to input graph
until the graph has m edges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Input graph.</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>Final num of edges.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>igraph object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addRandomEdges(graf, m):
    &#34;&#34;&#34;
    Add random Erdos--Renyi edges to input graph
    until the graph has m edges.

    Parameters
    ----------
    graf : igraph object
        Input graph.
    m : int
        Final num of edges.

    Returns
    -------
    igraph object.

    &#34;&#34;&#34;
    
    n = len(graf.vs)
    assert m &lt; n*(n-1)/2
    
    while(len(graf.es) &lt; m):
        m2 = m - len(graf.es)
        
        heads = choices(range(n), k=m2)
        tails = choices(range(n), k=m2)
        
        edgelist = [(heads[j], tails[j]) for j in range(m2) if heads[j] != tails[j]]

        graf.add_edges(edgelist)
        graf.simplify()
        
    return(graf)        </code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.bfsTree"><code class="name flex">
<span>def <span class="ident">bfsTree</span></span>(<span>graf, root=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a tree from a given node by breadth-first-search</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Input graph.</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Start node id. The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bfsTree(graf, root=0):
    &#34;&#34;&#34;
    Creates a tree from a given node by breadth-first-search

    Parameters
    ----------
    graf : igraph object
        Input graph.
    root : int, optional
        Start node id. The default is 0.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    n = len(graf.vs)
    
    graf.vs[&#34;marked&#34;] = False
    graf.es[&#34;tree&#34;] = False
    
    graf.vs[root][&#34;marked&#34;] = True
    
    myqueue = [root]
    
    while (len(myqueue) &gt; 0):
        v = myqueue.pop(0)
        
        edge_ixs = graf.incident(v)
        shuffle(edge_ixs)
        
        for eid in edge_ixs:
            my_e = graf.es[eid]
            u = otherNode(my_e, v)
            
            if (not graf.vs[u][&#34;marked&#34;]):
                my_e[&#34;tree&#34;] = True
                graf.vs[u][&#34;marked&#34;] = True
                myqueue.append(u)</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.countAllHist"><code class="name flex">
<span>def <span class="ident">countAllHist</span></span>(<span>graf, root)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes posterior root probs for a given tree.
Require: graf.es has "tree" attribute; graf.vs
has "subtree_size" and "pa" attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Input graph.</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>int</code></dt>
<dd>Root node id. Computes posterior root prob
for the tree containing root.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>0. nparray</code> of <code>posterior root probs</code></dt>
<dd>&nbsp;</dd>
<dt><code>1. cardinality</code> of <code>all histories</code> of <code>input tree</code></dt>
<dd>&nbsp;</dd>
<dt><code>2. largest h(u,t) value in log-scale</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def countAllHist(graf, root):
    &#34;&#34;&#34;
    Computes posterior root probs for a given tree. 
    Require: graf.es has &#34;tree&#34; attribute; graf.vs 
            has &#34;subtree_size&#34; and &#34;pa&#34; attributes.

    Parameters
    ----------
    graf : igraph object
        Input graph.
    root : int
        Root node id. Computes posterior root prob
        for the tree containing root. 

    Returns
    -------
    0. nparray of posterior root probs
    1. cardinality of all histories of input tree
    2. largest h(u,t) value in log-scale

    &#34;&#34;&#34;
    n = len(graf.vs)
    
    countSubtreeSizes(graf, root)
    hist = [0] * n
    
    ntree = graf.vs[root][&#34;subtree_size&#34;]
    
    S = collections.deque([root]) ## queue of nodes to visit

    hist[root] = 0
    tree_nodes = []
    
    while (len(S) &gt; 0):
        cur_node = S.popleft()
        tree_nodes.append(cur_node)
        
        hist[root] = hist[root] - np.log(graf.vs[cur_node][&#34;subtree_size&#34;])

        node_ixs = graf.neighbors(cur_node)
        for next_node in node_ixs:
            
            if (graf.vs[next_node][&#34;pa&#34;] != cur_node):
                continue
            S.append(next_node)
            
    S = collections.deque([root]) ## queue of nodes to visit
    
    while (len(S) &gt; 0):
        cur_node = S.popleft()
    
        node_ixs = graf.neighbors(cur_node)
        
        for next_node in node_ixs:
            
            if (graf.vs[next_node][&#34;pa&#34;] != cur_node):
                continue
            
            S.append(next_node)
            
            hist[next_node] = hist[cur_node] + \
                    np.log(graf.vs[next_node][&#34;subtree_size&#34;] /  \
                           (ntree - graf.vs[next_node][&#34;subtree_size&#34;]))
            
            
    loghist = np.array(hist)
    
    thist = np.array([0] * n, dtype=float)

    thist[tree_nodes] = np.exp(loghist[tree_nodes] - max(loghist[tree_nodes]))

    return((thist/np.sum(thist), np.sum(thist), max(loghist)))</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.countSubtreeSizes"><code class="name flex">
<span>def <span class="ident">countSubtreeSizes</span></span>(<span>graf, root, prev=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates new node attribute "subtree_size" and "pa"
giving the subtree sizes and parent of each node viewing the
input tree as being rooted at a given node.</p>
<p>Require: input graph edges have "tree" attribute.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Input graph; creates node attribute "subtree_size" on graf
creates node attribute "pa" on graf</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>int</code></dt>
<dd>Node id of root.</dd>
<dt><strong><code>prev</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Internal variable used for recursion. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def countSubtreeSizes(graf, root, prev=None):
    &#34;&#34;&#34;
    Creates new node attribute &#34;subtree_size&#34; and &#34;pa&#34;
    giving the subtree sizes and parent of each node viewing the 
    input tree as being rooted at a given node.
    
    Require: input graph edges have &#34;tree&#34; attribute.

    Parameters
    ----------
    graf : igraph object
        Input graph; creates node attribute &#34;subtree_size&#34; on graf
        creates node attribute &#34;pa&#34; on graf
    root : int
        Node id of root.
    prev : int, optional
        Internal variable used for recursion. The default is None.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    n = len(graf.vs)
    istree = len(graf.es) == (n-1)

    graf.vs[root][&#34;pa&#34;] = prev
    
    counter = 1
    
    edge_ixs = graf.incident(root)
    
    for eid in edge_ixs:
        my_e = graf.es[eid]
        if (not istree) and (not my_e[&#34;tree&#34;]):
            continue
        
        next_node = otherNode(my_e, root)
            
        if (next_node == prev):
            continue
        else:
            counter = counter + countSubtreeSizes(graf, next_node, root)
        
    graf.vs[root][&#34;subtree_size&#34;] = counter
    return(counter)</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.createNoisyGraph"><code class="name flex">
<span>def <span class="ident">createNoisyGraph</span></span>(<span>n, m, alpha=0, beta=1, K=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a new graph from PAPER(alpha, beta, K, theta) model
with n nodes and m edges.
Note: theta parameter not used since m is fixed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Num nodes.</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>Num edges.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Parameter. The default is 0.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Parameter. The default is 1.</dd>
<dt><strong><code>K</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Num of clusters. The default is 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>0. igraph object</code></dt>
<dd>&nbsp;</dd>
<dt><code>1. list representation</code> of <code>the underlying tree</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>where i-th element is the root of node i</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createNoisyGraph(n, m, alpha=0, beta=1, K=1):
    &#34;&#34;&#34;
    Generates a new graph from PAPER(alpha, beta, K, theta) model
    with n nodes and m edges. 
    Note: theta parameter not used since m is fixed.

    Parameters
    ----------
    n : int
        Num nodes.
    m : int
        Num edges.
    alpha : float, optional
        Parameter. The default is 0.
    beta : float, optional
        Parameter. The default is 1.
    K : int, optional
        Num of clusters. The default is 1.

    Returns
    -------
    0. igraph object
    1. list representation of the underlying tree
       where i-th element is the root of node i

    &#34;&#34;&#34;
    
    res = createPATree(n, alpha, beta, K)
    mytree = res[0]
    clust = res[1]
    
    addRandomEdges(mytree, m)
    return((mytree, clust))</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.createPATree"><code class="name flex">
<span>def <span class="ident">createPATree</span></span>(<span>n, alpha=0, beta=1, K=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an APA(alpha, beta, K) forest.
Default parameter is LPA.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Num nodes.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Parameter. The default is 0.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Parameter. The default is 1.</dd>
<dt><strong><code>K</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Num of component trees. The default is 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<ol>
<li>
<dl>
<dt>igraph object.</dt>
<dt><code>1. list representation</code> of <code>the underlying forest</code></dt>
<dd>&nbsp;</dd>
</dl>
</li>
</ol>
<p>where i-th element is the root of node i</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createPATree(n, alpha=0, beta=1, K=1):
    &#34;&#34;&#34;
    Generates an APA(alpha, beta, K) forest.
    Default parameter is LPA.

    Parameters
    ----------
    n : int
        Num nodes.
    alpha : float, optional
        Parameter. The default is 0.
    beta : float, optional
        Parameter. The default is 1.
    K : int, optional
        Num of component trees. The default is 1.

    Returns
    -------
    0. igraph object.
    1. list representation of the underlying forest
       where i-th element is the root of node i

    &#34;&#34;&#34;
    mytree = Graph()
    
    mytree.add_vertices(n)
    edge_ls = []
    
    ## parent of every node; -1 if root
    ## tree ID of every node
    pa_vec = [-1] * n
    tree_vec = [0] * n 
    
    if (K == 1):
        mytree.add_edges( [(0,1)] )
        wt_ls = [alpha+beta, alpha+beta]
        pa_vec[1] = 0
        initi = 2
    else :
        wt_ls = [alpha + 2*beta] * K
        initi = K
        for k in range(K):
            tree_vec[k] = k
    
    for i in range(initi, n):
        
        if (alpha == 1 and beta ==0):
            cur_node = choices(range(i))[0]
        else:
            cur_node = choices(range(i), weights=wt_ls)[0]
        
        wt_ls.append(alpha+beta)
        wt_ls[cur_node] = wt_ls[cur_node] + beta        
        edge_ls.append((cur_node, i))
        
        pa_vec[i] = cur_node
        
        while (pa_vec[cur_node] != -1):
            cur_node = pa_vec[cur_node]
        
        tree_vec[i] = cur_node
        
        
    mytree.add_edges(edge_ls)
    return((mytree, tree_vec))</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.getAllTreeDeg"><code class="name flex">
<span>def <span class="ident">getAllTreeDeg</span></span>(<span>graf)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes tree degree of all nodes in input graph.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Graph with tree attribute on edges.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np array of the tree degrees of all nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllTreeDeg(graf):
    &#34;&#34;&#34;
    Computes tree degree of all nodes in input graph.

    Parameters
    ----------
    graf : igraph object
        Graph with tree attribute on edges.

    Returns
    -------
    np array of the tree degrees of all nodes.

    &#34;&#34;&#34;
    n = len(graf.vs)
    degs = [0] * n
    for mye in graf.es:
        if (mye[&#34;tree&#34;]):
            degs[mye.source] = degs[mye.source] + 1
            degs[mye.target ] = degs[mye.target] + 1
    degs = np.array(degs)
    return(degs)</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.getAncestors"><code class="name flex">
<span>def <span class="ident">getAncestors</span></span>(<span>graf, utilde, u=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns ancestors utilde, avoiding u.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Input graph.</dd>
<dt><strong><code>utilde</code></strong> :&ensp;<code>int</code></dt>
<dd>node id.</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>node id. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>-1 if parents of utilde trace to u,
otherwise return list of parents of utilde, including utilde, including the root.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAncestors(graf, utilde, u = None):
    &#34;&#34;&#34;
    Returns ancestors utilde, avoiding u.

    Parameters
    ----------
    graf : igraph object
        Input graph.
    utilde : int
        node id.
    u : int, optional
        node id. The default is None.

    Returns
    -------
    -1 if parents of utilde trace to u, 
          otherwise return list of parents of utilde, including utilde, including the root.

    &#34;&#34;&#34;
    
    cur_node = utilde
    ants = [cur_node]
    
    while (True):
        my_pa = graf.vs[cur_node][&#34;pa&#34;]
        
        if (my_pa == None):
            return(ants)

        assert graf.vs[cur_node][&#34;subtree_size&#34;] &lt; graf.vs[my_pa][&#34;subtree_size&#34;]
        
        if (my_pa == u):
            return(-1)
        else:
            ants.append(my_pa)
            cur_node = my_pa</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.getTreeSizes"><code class="name flex">
<span>def <span class="ident">getTreeSizes</span></span>(<span>graf, tree2root)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Input graph.</dd>
<dt><strong><code>tree2root</code></strong> :&ensp;<code>list</code></dt>
<dd>Root node of all trees.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>0. list</code> of <code>sizes</code> of <code>all trees</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTreeSizes(graf, tree2root):
    &#34;&#34;&#34;

    Parameters
    ----------
    graf : igraph object
        Input graph.
    tree2root : list
        Root node of all trees.

    Returns
    -------
    0. list of sizes of all trees

    &#34;&#34;&#34;
    n = len(graf.vs)
    all_sizes = []
    for k in range(len(tree2root)):
        cur_tree = treeDFS(graf, tree2root[k], range(n))
        all_sizes.append(len(cur_tree))
    
    assert sum(np.array(all_sizes)) == n
    
    return(all_sizes)</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.otherNode"><code class="name flex">
<span>def <span class="ident">otherNode</span></span>(<span>my_edge, node_ix)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives other node id of a given edge and one endpoint id</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>my_edge</code></strong> :&ensp;<code>igraph edge object</code></dt>
<dd>Input edge.</dd>
<dt><strong><code>node_ix</code></strong> :&ensp;<code>int</code></dt>
<dd>One endpoint id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Node id of the other endpoint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def otherNode(my_edge, node_ix):
    &#34;&#34;&#34;
    Gives other node id of a given edge and one endpoint id

    Parameters
    ----------
    my_edge : igraph edge object
        Input edge.
    node_ix : int
        One endpoint id.

    Returns
    -------
    Node id of the other endpoint.

    &#34;&#34;&#34;
    if (my_edge.source == node_ix):
        return(my_edge.target)
    else:
        return(my_edge.source)      </code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.treeDFS"><code class="name flex">
<span>def <span class="ident">treeDFS</span></span>(<span>graf, start, v_ls=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Require: edges of "graf" has a "tree" attribute</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Input graph.</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code></dt>
<dd>Start node id.</dd>
<dt><strong><code>v_ls</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of nodes. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>0. sublist</code> of <code>v_ls</code> of <code>all nodes in the tree</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>containg start node. If v_ls==None, returns
list of all nodes of tree containing start node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treeDFS(graf, start, v_ls=None):
    &#34;&#34;&#34;
    Require: edges of &#34;graf&#34; has a &#34;tree&#34; attribute

    Parameters
    ----------
    graf : igraph object
        Input graph.
    start : int
        Start node id.
    v_ls : list, optional
        List of nodes. The default is None.

    Returns
    -------
    0. sublist of v_ls of all nodes in the tree
       containg start node. If v_ls==None, returns
       list of all nodes of tree containing start node.

    &#34;&#34;&#34;
    
    stak = [start]
    
    visited = {}
    
    while (len(stak) &gt; 0):
        cur_v = stak.pop(-1)
        visited[cur_v] = 1
        tree_edges = [e for e in graf.incident(cur_v) if graf.es[e][&#34;tree&#34;]]
        tree_nbs = [otherNode(graf.es[e], cur_v) for e in tree_edges]
    
        for u in tree_nbs:
            if u not in visited:
                stak.append(u)
    if (v_ls != None):
        tmp = [v for v in v_ls if v in visited]
    else:
        tmp = list(visited.keys())
        
    return(tmp)</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.treeDegree"><code class="name flex">
<span>def <span class="ident">treeDegree</span></span>(<span>graf, v)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes tree degree of a single node v of the input graph</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Graph with tree attribute on edges.</dd>
<dt><strong><code>v</code></strong> :&ensp;<code>int</code></dt>
<dd>node id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tree degree of v as a single integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treeDegree(graf, v):
    &#34;&#34;&#34;
    Computes tree degree of a single node v of the input graph

    Parameters
    ----------
    graf : igraph object
        Graph with tree attribute on edges.
    v : int
        node id.

    Returns
    -------
    tree degree of v as a single integer.

    &#34;&#34;&#34;
    
    edge_ixs = graf.incident(v)
    
    deg = sum([e[&#34;tree&#34;] for e in graf.es[edge_ixs]])
    
    return(deg)</code></pre>
</details>
</dd>
<dt id="PAPER.tree_tools.wilsonTree"><code class="name flex">
<span>def <span class="ident">wilsonTree</span></span>(<span>graf, root=0, display=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a tree from a given node by uniform sampling
from the set of spanning trees by Wilson's algorithm.
The starting node can be arbitrary. </p>
<p>Adds "tree" attribute to input graph edges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graf</code></strong> :&ensp;<code>igraph object</code></dt>
<dd>Input graph.</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Start node id; Does not affect output tree. The default is 0.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Display details. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wilsonTree(graf, root=0, display=False):
    &#34;&#34;&#34;
    Creates a tree from a given node by uniform sampling
    from the set of spanning trees by Wilson&#39;s algorithm. 
    The starting node can be arbitrary. 

    Adds &#34;tree&#34; attribute to input graph edges.

    Parameters
    ----------
    graf : igraph object
        Input graph.
    root : int, optional
        Start node id; Does not affect output tree. The default is 0.
    display : boolean, optional
        Display details. The default is False.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    
    n = len(graf.vs)
    vertex_seq = range(n)
    
    graf.es[&#34;tree&#34;] = False
    graf.vs[&#34;marked&#34;] = False
    graf.vs[root][&#34;marked&#34;] = True
    
    
    def loopErase(mylist):
        occur = {}
        for ii in range(len(mylist)):
            occur[mylist[ii]] = ii
            
        outlist = []
        ii = 0
        while (True):
            if ii &gt;= len(mylist):
                return(outlist)
            
            if (occur[mylist[ii]] == ii):
                outlist.append(mylist[ii])
                ii = ii + 1
            else:
                ii = occur[mylist[ii]]
        
    
    def loopErasedRW(start):
        cur_node = start
        node_ls = [cur_node]
        
        while (True):
            cur_node = choices(graf.neighbors(cur_node), k=1)[0]
            node_ls.append(cur_node)
            
            #if (cur_node == start):
            #    node_ls = [cur_node]
                
            if (graf.vs[cur_node][&#34;marked&#34;]):
                
                node_ls = loopErase(node_ls)
                
                graf.vs[node_ls][&#34;marked&#34;] = True
                my_edge_ids = graf.get_eids(path=node_ls)
                
                graf.es[my_edge_ids][&#34;tree&#34;] = True
                return
            
            
    for ii in vertex_seq:
        if (display):
            if (ii % 10000 == 0):
                print((ii, n))
        if graf.vs[ii][&#34;marked&#34;]:
            continue
        else:
            loopErasedRW(ii)
            
    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PAPER" href="index.html">PAPER</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="PAPER.tree_tools.addRandomEdges" href="#PAPER.tree_tools.addRandomEdges">addRandomEdges</a></code></li>
<li><code><a title="PAPER.tree_tools.bfsTree" href="#PAPER.tree_tools.bfsTree">bfsTree</a></code></li>
<li><code><a title="PAPER.tree_tools.countAllHist" href="#PAPER.tree_tools.countAllHist">countAllHist</a></code></li>
<li><code><a title="PAPER.tree_tools.countSubtreeSizes" href="#PAPER.tree_tools.countSubtreeSizes">countSubtreeSizes</a></code></li>
<li><code><a title="PAPER.tree_tools.createNoisyGraph" href="#PAPER.tree_tools.createNoisyGraph">createNoisyGraph</a></code></li>
<li><code><a title="PAPER.tree_tools.createPATree" href="#PAPER.tree_tools.createPATree">createPATree</a></code></li>
<li><code><a title="PAPER.tree_tools.getAllTreeDeg" href="#PAPER.tree_tools.getAllTreeDeg">getAllTreeDeg</a></code></li>
<li><code><a title="PAPER.tree_tools.getAncestors" href="#PAPER.tree_tools.getAncestors">getAncestors</a></code></li>
<li><code><a title="PAPER.tree_tools.getTreeSizes" href="#PAPER.tree_tools.getTreeSizes">getTreeSizes</a></code></li>
<li><code><a title="PAPER.tree_tools.otherNode" href="#PAPER.tree_tools.otherNode">otherNode</a></code></li>
<li><code><a title="PAPER.tree_tools.treeDFS" href="#PAPER.tree_tools.treeDFS">treeDFS</a></code></li>
<li><code><a title="PAPER.tree_tools.treeDegree" href="#PAPER.tree_tools.treeDegree">treeDegree</a></code></li>
<li><code><a title="PAPER.tree_tools.wilsonTree" href="#PAPER.tree_tools.wilsonTree">wilsonTree</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>