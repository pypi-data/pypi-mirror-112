# AUTOGENERATED! DO NOT EDIT! File to edit: 02_design.ipynb (unless otherwise specified).

__all__ = ['reverse_compliment', 'calculate_global_position', 'traverse_global_position', 'get_sgrna_global_indices',
           'get_trainscript_region_info', 'get_target_regions_df', 'get_target_regions_sequences',
           'merge_target_region_sequence_df', 'get_transcript_sgrnas', 'filter_sgrnas_by_region', 'flag_sgrnas',
           'design_sgrna_tiling_library']

# Cell
import pandas as pd
from sgrna_designer import ensembl
from sgrna_designer import tile

# Cell
def reverse_compliment(seq):
    """Return the reverse compliment of a sequence

    seq: str |

    return: str
    """
    compliment = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'}
    reverse = seq[::-1]
    rev_comp = ''.join([compliment[nt] for nt in reverse])
    return rev_comp

# Cell
def calculate_global_position(strand, start, end, relative_position):
    """Calculate the global position of locus in a subsequence

    strand: int [1 or -1], strand of DNA sequence |
    start: int, global start position of sequence |
    end: int, global end position of sequence |
    relative_position: list of int, positions of sgRNAs relative to sequence |

    returns: list of int
    """
    if strand == 1:
        global_position = [start + x for x in relative_position]
    elif strand == -1:
        global_position = [end - x for x in relative_position]
    else:
        raise ValueError("Strand must be 1 or -1")
    return global_position

# Cell
def traverse_global_position(strand, reference_position, distance):
    """Move from one global position to another

    strand: int [1 or -1], strand of DNA sequence |
    reference_position: list of int, global starting position |
    distance: int, distance to move 5' to 3' on either strand |

    returns: list of int
    """
    if strand == 1:
        new_position = [x + distance for x in reference_position]
    elif strand == -1:
        new_position = [x - distance for x in reference_position]
    else:
        raise ValueError("Strand must be 1 or -1")
    return new_position

# Cell
def get_sgrna_global_indices(sgrna_df, seq_start, seq_end, strand, sg_positions=None):
    """Take an sgrna_df and return the globabl positions of elements of the sgRNA

    sgrna_df: Dataframe from `build_sgrna_df` |
    seq_start: int, starting index of sequence |
    seq_end: int, ending index of sequence |
    strand: int [1 or -1], strand of DNA sequence |
    sg_positions: list, positions within the sgRNA to annotate (e.g. [4,8] for nucleotides 4 and 8 of the sgRNA) |

    returns: DataFrame
    """
    indexed_sgrna_df = sgrna_df.copy()
    indexed_sgrna_df['sgrna_global_start'] = calculate_global_position(strand, seq_start, seq_end,
                                                                       indexed_sgrna_df['sgrna_relative_start'])
    if sg_positions is not None:
        for pos in sg_positions:
            indexed_sgrna_df['sgrna_global_' + str(pos)] = traverse_global_position(strand,
                                                                                    indexed_sgrna_df['sgrna_global_start'],
                                                                                    pos-1)
    indexed_sgrna_df = indexed_sgrna_df.drop('sgrna_relative_start', axis=1)
    return indexed_sgrna_df

# Cell
def get_trainscript_region_info(transcript_info, region_parent, region):
    """Return dictionaries for specified regions of interest

    transcript_info: dict, returned by https://rest.ensembl.org/documentation/info/lookup |
    region_parent: str, first level key in transcript_info eg. UTR |
    region: str, second level key in trancript_info eg. three_prime_UTR |

    returns: list of dict
    """
    if region_parent in transcript_info.keys():
        parent_info = transcript_info[region_parent]
        regions = []
        for r in parent_info:
            if r['object_type'] == region:
                regions.append(r)
    else:
        raise ValueError(region_parent + ' or ' + region + 'element could not be identified')
    return regions

def get_target_regions_df(target_transcripts, region_parent, region,
                          expand_3prime, expand_5prime):
    """For a list of transcripts return the locations for a specific region (e.g. three_prime_UTR)

    target_transcripts: list of str
    region_parent: str, first level key in transcript_info eg. UTR |
    region: str, second level key in trancript_info eg. three_prime_UTR |
    expand_3prime: int, length to expand region in 3' direction |
    expand_5prime: int, length to expand region in 5' direction |

    returns: DataFrame of target regions
    """
    target_transcript_info = []
    for transcript in target_transcripts:
        transcript_info = ensembl.get_ensembl_id_information(transcript)
        region_info = get_trainscript_region_info(transcript_info, region_parent, region)
        region_info_df = pd.DataFrame(region_info)
        region_info_df['transcript_id'] = transcript
        target_transcript_info.append(region_info_df)
    target_regions_df = pd.concat(target_transcript_info)
    target_regions_df['expanded_start'] = target_regions_df['start'] - expand_3prime
    target_regions_df['expanded_end'] = target_regions_df['end'] + expand_5prime
    # We keep track of region_pos for merging with the target_sequence_df
    target_regions_df['region_pos'] = target_regions_df.apply(lambda row:
                                                              ensembl.create_region_str(row['expanded_start'],
                                                                                        row['expanded_end'],
                                                                                        row['seq_region_name']),
                                                              axis=1)
    return target_regions_df

# Cell
def get_target_regions_sequences(target_regions_df):
    """Get sequences from a DataFrame of target regions

    target_regions_df: DataFrame from `get_target_regions_df`

    returns: DataFrame
    """
    target_sequences = ensembl.post_region_sequences(target_regions_df['expanded_start'],
                                                     target_regions_df['expanded_end'],
                                                     target_regions_df['seq_region_name'])
    target_sequence_df = pd.DataFrame(target_sequences)
    return target_sequence_df

# Cell
def merge_target_region_sequence_df(target_regions_df, target_sequences_df):
    """Merge target regions and target sequences dataframes

    target_regions_df:  DataFrame, from `get_target_regions_df` |
    target_sequences_df: DataFrame, from `get_target_regions_sequences` |

    returns: DataFrame
    """
    target_region_seq_df = (target_regions_df
                            .rename({'id': 'region_id'}, axis=1)
                            .merge(target_sequences_df
                                   .rename({'query': 'region_pos',
                                            'id': 'region_pos_id'}, axis=1), how='inner', on='region_pos'))
    return target_region_seq_df

# Cell
def get_transcript_sgrnas(target_region_seq_df, context_len, pam_start, pam_len,
                          sgrna_start, sgrna_len, pams, sg_positions):
    """Get all sgRNAs targeting transcript regions

    target_region_seq_df: DataFrame, from `merge_target_region_sequence_df`
    context_len: int, length of context sequence |
    pam_start: int, position of PAM start relative to the context sequence |
    pam_len: int, length of PAM |
    sgrna_start: int, position of sgRNA relative to context sequence |
    sgrna_len: length of sgRNA sequence |
    pams: list or None, PAMs to design against |
    sg_positions: list of int, positions within the sgRNA to annotate
    (e.g. [4,8] for nucleotides 4 and 8 of the sgRNA) |

    returns DataFrame
    """
    sgrna_df_list = []
    meta_columns = ['object_type', 'strand', 'transcript_id', 'seq_region_name', 'region_id', 'start', 'end']
    for i, row in target_region_seq_df.iterrows():
        seq_start = row['expanded_start']
        seq_end = row['expanded_end']
        sequence = row['seq']
        # Sequences on the positive strand
        pos_sgrna_df = tile.build_sgrna_df(sequence, context_len=context_len, pam_start=pam_start,
                                           pam_len=pam_len, sgrna_start=sgrna_start,
                                           sgrna_len=sgrna_len, pams=pams)
        pos_sgrna_df = get_sgrna_global_indices(pos_sgrna_df, seq_start, seq_end, 1, sg_positions)
        # assuming the target_region_seq_df is oriented on the positive sgRNA strand
        pos_sgrna_df['sgrna_strand'] = 1
        # Sequences on the negative strand
        rev_comp_seq = reverse_compliment(sequence)
        neg_sgrna_df = tile.build_sgrna_df(rev_comp_seq, context_len=context_len, pam_start=pam_start,
                                           pam_len=pam_len, sgrna_start=sgrna_start,
                                           sgrna_len=sgrna_len, pams=pams)
        neg_sgrna_df = get_sgrna_global_indices(neg_sgrna_df, seq_start, seq_end, -1, sg_positions)
        neg_sgrna_df['sgrna_strand'] = -1
        # Combine and filter sgrna_dfs
        sgrna_df = pd.concat([pos_sgrna_df, neg_sgrna_df])
        for col in meta_columns:
            sgrna_df[col] = row[col]
        sgrna_df_list.append(sgrna_df)
    concatenated_sgrna_dfs = (pd.concat(sgrna_df_list)
                              .rename({'strand': 'transcript_strand',
                                       'start': 'region_start',
                                       'end': 'region_end',
                                       'seq_region_name': 'chromosome'}, axis=1))
    return concatenated_sgrna_dfs

# Cell
def filter_sgrnas_by_region(transcript_sgrna_df, sg_positions):
    """Filter for sgRNAs such that the specified sgRNA positions are within the region of interest

    transcript_sgrna_df: DataFrame, from`get_transcript_sgrnas`
    sg_positions: list of int, positions within the sgRNA to annotate
    (e.g. [4,8] for nucleotides 4 and 8 of the sgRNA) |

    returns: DataFrame, filtered for sgRNAs that fall within the target region
    """
    global_pos_cols = []
    for pos in sg_positions:
        global_pos_cols.append('sgrna_global_' + str(pos))
    filtered_sgrna_df = transcript_sgrna_df[
        ((transcript_sgrna_df[global_pos_cols].min(axis=1) >= transcript_sgrna_df['region_start']) &
         (transcript_sgrna_df[global_pos_cols].min(axis=1) <= transcript_sgrna_df['region_end'])) |
        ((transcript_sgrna_df[global_pos_cols].max(axis=1) >= transcript_sgrna_df['region_start']) &
         (transcript_sgrna_df[global_pos_cols].max(axis=1) <= transcript_sgrna_df['region_end']))
    ].reset_index(drop=True)
    return filtered_sgrna_df

# Cell
def flag_sgrnas(sgrna_df, flag_seqs, flag_seqs_start, flag_seqs_end):
    """Flag problematic subsequences (e.g. TTTT) in sgRNAs

    sgrna_df: DataFrame |
    flag_seqs: list of str, flag subsequences anywhere in sgRNA sequences |
    flag_seqs_start: list of str, flag subsequences at the beginning of sgRNA sequences |
    flag_seqs_end: list of str, flag subsequences at the end of sgRNA sequences |

    returns: DataFrame, with additional columns to flag problematic sgRNAs
    """
    flagged_df = sgrna_df.copy()
    flag_cols = []
    for seq in flag_seqs:
        flagged_df[seq] = [seq if x else None for x in flagged_df['sgrna_sequence'].str.contains(seq)]
        flag_cols.append(seq)
    for seq in flag_seqs_start:
        seq_str = '(start)' + seq
        flagged_df[seq_str] = [seq_str if x else None for x in flagged_df['sgrna_sequence'].str.startswith(seq)]
        flag_cols.append(seq_str)
    for seq in flag_seqs_end:
        seq_str = seq + '(end)'
        flagged_df[seq_str] = [seq_str if x else None for x in flagged_df['sgrna_sequence'].str.endswith(seq)]
        flag_cols.append(seq_str)
    flagged_df['flag'] = flagged_df[flag_cols].apply(
        lambda row: ', '.join([x for x in row if not pd.isna(x)]), axis=1)
    flagged_df = flagged_df.drop(flag_cols, axis=1)
    return flagged_df

# Cell
def design_sgrna_tiling_library(target_transcripts, region_parent, region,
                                expand_3prime, expand_5prime, context_len,
                                pam_start, pam_len, sgrna_start, sgrna_len,
                                pams, sg_positions, flag_seqs, flag_seqs_start,
                                flag_seqs_end):
    """Design sgRNAs tiling transcript regions

    target_transcripts: list of str
    region_parent: str, first level key in transcript_info eg. UTR |
    region: str, second level key in trancript_info eg. three_prime_UTR |
    expand_3prime: int, length to expand region in 3' direction |
    expand_5prime: int, length to expand region in 5' direction |
    context_len: int, length of context sequence |
    pam_start: int, position of PAM start relative to the context sequence |
    pam_len: int, length of PAM |
    sgrna_start: int, position of sgRNA relative to context sequence |
    sgrna_len: length of sgRNA sequence |
    pams: list or None, PAMs to design against |
    sg_positions: list of int, positions within the sgRNA to annotate
        (e.g. [4,8] for nucleotides 4 and 8 of the sgRNA) |
    flag_seqs: list of str, flag subsequences anywhere in sgRNA sequences |
    flag_seqs_start: list of str, flag subsequences at the beginning of sgRNA sequences |
    flag_seqs_end: list of str, flag subsequences at the end of sgRNA sequences |

    returns: DataFrame, sgRNAs for transcript regions of interest
    """
    target_regions_df = get_target_regions_df(target_transcripts=target_transcripts, region_parent=region_parent,
                                              region=region, expand_3prime=expand_3prime,
                                              expand_5prime=expand_5prime)
    target_sequences_df = get_target_regions_sequences(target_regions_df)
    target_region_seq_df = merge_target_region_sequence_df(target_regions_df, target_sequences_df)
    transcript_sgrna_df = get_transcript_sgrnas(target_region_seq_df, context_len=context_len, pam_start=pam_start,
                                                pam_len=pam_len, sgrna_start=sgrna_start, sgrna_len=sgrna_len,
                                                pams=pams, sg_positions=sg_positions)
    filtered_sgrnas = filter_sgrnas_by_region(transcript_sgrna_df, sg_positions)
    flagged_sgrnas = flag_sgrnas(filtered_sgrnas, flag_seqs=flag_seqs, flag_seqs_start=flag_seqs_start,
                                 flag_seqs_end=flag_seqs_end)
    return flagged_sgrnas