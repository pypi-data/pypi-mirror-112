# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['subscribe']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'subscribe',
    'version': '0.6.1',
    'description': 'Library for managing subscriptions',
    'long_description': '# Subscribe\n\nA simple yet powerfull subscription library in Python for managing subscriptions.\n\n## Concepts\n\nEvery subscription consists of\n\n- *subscription_list* - a unique identification (just a string) for a list to which is subscribed\n- *prio* - a integer with the prio of the subscription which will be used to order the subscriptions\n  (from low to high)\n- *subscriber* - The object which is subscribed. Can be anything. Often a callable,.\n\n`subscribe` is very flexible and may require some boilerplate to setup. For some frequent use cases\nwe have made helpers: `Event` and `Command`. These are simply to use, so we will the tutorial with\nthese.\n\n\n## Quick start\n\n   Import subscribe\n\n    >>> import subscribe\n\n### Event\n\n    An Event is a class whose instance can be used to notify handler, which will\n    receive the event as single argument.\n\n    Create an Event\n\n    >>> class UserCreated(subscribe.Event):\n    ...     def __init__(self, name: str):\n    ...         self.name = name\n    ...         self.notify()\n\n    >>> called_handlers = []\n\n    Add some subscribers\n\n    >>> @UserCreated.subscribe\n    ... def send_mail(event: UserCreated):\n    ...     called_handlers.append(f"Send email to {event.name}")\n\n    >>> @UserCreated.subscribe\n    ... def add_default_groups(event: UserCreated):\n    ...     called_handlers.append(f"Add default groups {event.name}")\n\n    Instantiate the event (and call the handlers, because the `__init__`\n    method calls the `notify` method).\n\n    >>> user_created = UserCreated("marc")\n\n    >>> called_handlers\n    [\'Send email to marc\', \'Add default groups marc\']\n\n\n### Command\n\n    A command is special kind of event, with the following differences:\n    - A command must have exactly 1 handler\n    - The command will return the return value of the handler\n\n    Create a Command\n\n    >>> class SendEmail(subscribe.Command):\n    ...     def __init__(self, message: str):\n    ...         self.message = message\n\n    >>> called_handlers = []\n\n    Add a subscriber\n\n    >>> @SendEmail.subscribe\n    ... def send_mail(event: SendEmail, email: str):\n    ...     called_handlers.append(f"Send email to {email}")\n    ...     return email\n\n    >>> user_created = SendEmail("Welcome")\n    >>> user_created.execute(email="marc@rijken.org")\n    \'marc@rijken.org\'\n\n    >>> user_created.execute(email="john@example.com")\n    \'john@example.com\'\n\n    >>> called_handlers\n    [\'Send email to marc@rijken.org\', \'Send email to john@example.com\']\n\n## Flexible subscriptions\n\n`Event` and `Command` are two predefined use cases of subscriptions. You\ncan define your own to get more flexibility, both in defining the subscribers\nand subscriptions as calling the subcriptions.\n\n### SubscriptionList\n\n    Subscriptions are collected in a `SubscriptionList` which is identified by a\n    string. It is easy to create one.\n\n    >>> new_user = subscribe.SubscriptionList("new_user")\n\n### Subscribe to the SubscriptionList\n\n    You can add a subscriber by using the `subscribe` decorator of the\n    SubscriptionList.\n\n    >>> @new_user.subscribe()\n    ... def send_mail(user):\n    ...     pass\n\n    The subscribers can be anything, so they do not have to be callables.\n\n    You can subscribe multiple subscribers to the same SubscriptionList.\n    The subscribers will be sorted in order of priority. When no priority is given, the priority\n    will be equal to 0 and the subscriptions will be in order of addition.\n\n    >>> @new_user.subscribe(priority=-1)\n    ... def compute_age(user):\n    ...     pass\n\n\n### Get the subscriptions\n\n    You can get the subscriptions (which contains the subscriber, subscription list and priortiy), \n    ie so you call the subscribed functions. Of course you can not call the subscribers if \n    they are not callable, but you\n    can iterate over them to do whatever you want.\n\n    >>> [i for i in new_user.get_subscriptions()]\n    [Subscription(subscription_list=<SubscriptionList id=\'new_user\'>, priority=-1, subscriber=<function compute_age at ...>), Subscription(subscription_list=<SubscriptionList id=\'new_user\'>, priority=0, subscriber=<function send_mail at ...>)]\n\n    Or just the subscribers, which is most of the time what you want\n\n    >>> [i.__name__ for i in new_user.get_subscribers()]\n    [\'compute_age\', \'send_mail\']\n\n    You can also use the `subscribers` property.\n\n    >>> [i.__name__ for i in new_user.subscribers]\n    [\'compute_age\', \'send_mail\']\n\n    Often the subscribers are callables. You can call them all with\n    the same parameters. Note: return value will not be collected and returned\n    \n    >>> new_user.call_subscribers(user="marc")\n\n\n### Advanced Usage\n\n#### Class based SubscriptionList\n\n    An important use case is to subscribe to classes, which\n    will use the fully qualified name of the class as the\n    SubscriptionLIst identification.\n\n    >>> class EventBase:\n    ...   pass\n    >>> class NewUserEvent(EventBase):\n    ...   pass\n\n    >>> new_user_event = subscribe.ClassSubscriptionList(NewUserEvent)\n    >>> new_user_event\n    <ClassSubscriptionList class=\'__main__.NewUserEvent\'>\n\n    You do not have to pass the subscription list around; you can\n    recreate it:\n\n    >>> new_user_event == subscribe.ClassSubscriptionList(NewUserEvent)\n    True\n\n    And use it as a regular SubscriptionList to subscribe.\n\n    >>> @new_user_event.subscribe()\n    ... def subscriber1():\n    ...     pass\n    >>> @new_user_event.subscribe()\n    ... def subscriber2():\n    ...     pass\n\n    And get the subscribers as a regular SubscriptionList.\n\n    >>> list(new_user_event.get_subscribers()) == [subscriber1, subscriber2]\n    True\n    >>> list(new_user_event.subscribers) == [subscriber1, subscriber2]\n    True\n\n    If you do not have the instance of the SubscriptionList anymore, you can\n    get a new one by passing the class or the instance to ClassSubscriptionList.\n\n    >>> list(subscribe.ClassSubscriptionList(NewUserEvent).subscribers) == [subscriber1, subscriber2]\n    True\n\n    >>> list(subscribe.ClassSubscriptionList(NewUserEvent()).subscribers) == [subscriber1, subscriber2]\n    True\n\n### Superclass\n\n    ClassSubscriptionList will iterate over the subscribers for the exact same class. If you want to\n    use the superclass to iterate over all it subscribers and the subscribers of it\'s subclasses,\n    you have to use SuperClassSubscriptionList\n\n    >>> super_new_user_event = subscribe.SuperClassSubscriptionList(NewUserEvent)\n    >>> base_event = subscribe.SuperClassSubscriptionList(EventBase)\n\n    The subclass still has the same subscribers\n\n    >>> list(super_new_user_event.subscribers) == [subscriber1, subscriber2]\n    True\n\n    When we create a subscriber on the superclass\n\n    >>> @base_event.subscribe()\n    ... def event_subscriber():\n    ...     pass\n\n    that will be visible as subscriber on the subclass.\n\n    >>> list(super_new_user_event.subscribers) == [subscriber1, subscriber2, event_subscriber]\n    True\n\n    And on the superclass\n\n    >>> list(base_event.subscribers) == [event_subscriber]\n    True\n\n#### Prefix on names\n\n    The class name will be used for the identification. So if you want to create\n    different SubscriptionLists for the same class, you can add a prefix to the\n    SubscriptionList:\n\n    When a prefix is used, `partial` can be used to make sure the right prefix is used every time.\n    \n    >>> prefixed_new_user_event = subscribe.ClassSubscriptionList(NewUserEvent, prefix=\'my_prefix\')\n    >>> prefixed_new_user_event == new_user_event\n    False\n\n    You can use partial to make sure that you uses the same prefix.\n\n    >>> import functools\n    >>> PrefixedClassSubscriptionList = functools.partial(subscribe.ClassSubscriptionList, prefix=\'my_prefix\')\n    >>> prefixed_new_user_event = PrefixedClassSubscriptionList(NewUserEvent)\n    >>> @prefixed_new_user_event.subscribe()\n    ... def subscriber5():\n    ...     pass\n    >>> list(prefixed_new_user_event.subscribers) == [subscriber5]\n    True\n\n\n\n#### Multiple instantiation\n\n    A subscription list can be created multiple times\n\n    >>> first = subscribe.SubscriptionList("my list")\n    >>> second = subscribe.SubscriptionList("my list")\n\n    Both can be used to subscribe.\n\n    >>> first.subscribe()("subscribe to first")\n    \'subscribe to first\'\n    >>> second.subscribe()("subscribe to second")\n    \'subscribe to second\'\n\n    Both will have the same subscriptions.\n\n    >>> [i.subscriber for i in first.get_subscriptions()]\n    [\'subscribe to first\', \'subscribe to second\']\n    >>> [i.subscriber for i in second.get_subscriptions()]\n    [\'subscribe to first\', \'subscribe to second\']\n    \n#### Subclass SubscriptionList\n\n    You can subclass SubscriptionList, like we did with ClassSubscriptionList.\n\n    For example, if you have users.\n\n    >>> class User:\n    ...     def __init__(self, username):\n    ...         self.username = username\n\n    Which could be used to subscribe to, like subscribing to Twitter accounts\n\n    >>> class UserSubscriptionList(subscribe.SubscriptionList):\n    ...     def __init__(self, user: User):\n    ...         super().__init__(f"user:{user.username}")\n\n    Note: the subscription list is in memory and not persistent. You can implement your own \n    persistency for your SubscriptionList subclass when appropriate.',
    'author': 'Marc Rijken',
    'author_email': 'marc@rijken.org',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/mrijken/subscribe',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.6.2,<4.0',
}


setup(**setup_kwargs)
